Entendimento do Monitor Engine:
O Monitor Engine é responsável por monitorar o consumo de dados de cada usuário móvel e gerar alertas quando o consumo atinge determinados limites, além de enviar estatísticas periódicas ao BackOffice User.
Implementação:
Alertas de Consumo:
O Monitor Engine precisa verificar periodicamente o consumo de dados de cada usuário.
Quando o consumo atinge 80%, 90% ou 100% do plafond inicial, o Monitor Engine deve gerar um alerta para o respectivo usuário através da Message Queue.
Isso pode ser feito lendo os dados da Shared Memory, onde o consumo de cada usuário é armazenado.
Estatísticas Periódicas:
O Monitor Engine deve gerar estatísticas periódicas de consumo de dados.
Isso envolve calcular o consumo total de dados em intervalos regulares (por exemplo, a cada 30 segundos).
As estatísticas geradas devem ser enviadas ao BackOffice User através da Message Queue.
Comunicação:
O Monitor Engine precisa se comunicar com outros componentes do sistema, principalmente com a Shared Memory para acessar os dados de consumo dos usuários e com o BackOffice User para enviar as estatísticas.
Utilize os mecanismos de IPC (Inter-Process Communication) fornecidos, como Message Queue, para enviar alertas e estatísticas.
Tratamento de Sinais:
O Monitor Engine deve tratar o sinal SIGINT para garantir uma saída controlada do programa quando o sistema for encerrado.
Ao receber o sinal SIGINT, o Monitor Engine deve primeiro registrar no log que o programa está encerrando e, em seguida, terminar suas operações, liberando todos os recursos alocados.
Log e Debug:
Todas as atividades do Monitor Engine devem ser registradas no arquivo de log, incluindo a geração de alertas e estatísticas.
Inclua mensagens de depuração no código para facilitar o acompanhamento da execução do programa.
Controle de Concorrência:
Garanta que o acesso aos dados compartilhados seja sincronizado para evitar condições de corrida.
Use semáforos, mutexes ou variáveis de condição para sincronização, conforme necessário.
Implementação Limpa:
Siga as boas práticas de codificação, como modularização e comentários claros no código, para garantir uma implementação limpa e compreensível.